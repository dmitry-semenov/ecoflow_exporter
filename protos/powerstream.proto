syntax = "proto3";

package protos;

import "google/protobuf/descriptor.proto";

message MappingOptions {
  // divide the incoming value by this
  optional uint32 divisor = 1;
}

extend google.protobuf.FieldOptions {
  optional MappingOptions mapping_options = 50002;
}

/* cmd_id == 1 */
message InverterHeartbeat {
    optional uint32 inv_error_code = 1;
    optional uint32 inv_warning_code = 3;
    optional uint32 pv1_error_code = 2;
    optional uint32 pv1_warning_code = 4;
    optional uint32 pv2_error_code = 5;
    optional uint32 pv2_warning_code = 6;
    optional uint32 bat_error_code = 7;
    optional uint32 bat_warning_code = 8;
    optional uint32 llc_error_code = 9;
    optional uint32 llc_warning_code = 10;
    optional uint32 pv1_status = 11;
    optional uint32 pv2_status = 12;
    optional uint32 bat_status = 13;
    optional uint32 llc_status = 14;
    optional uint32 inv_status = 15;
    optional int32 pv1_input_volt = 16 [(mapping_options) = { divisor: 10 }];
    optional int32 pv1_op_volt = 17 [(mapping_options) = { divisor: 100 }];
    optional int32 pv1_input_cur = 18 [(mapping_options) = { divisor: 10 }];
    optional int32 pv1_input_watts = 19 [(mapping_options) = { divisor: 10 }];
    optional int32 pv1_temp = 20 [(mapping_options) = { divisor: 10 }];
    optional int32 pv2_input_volt = 21 [(mapping_options) = { divisor: 10 }];
    optional int32 pv2_op_volt = 22 [(mapping_options) = { divisor: 100 }];
    optional int32 pv2_input_cur = 23 [(mapping_options) = { divisor: 10 }];
    optional int32 pv2_input_watts = 24 [(mapping_options) = { divisor: 10 }];
    optional int32 pv2_temp = 25 [(mapping_options) = { divisor: 10 }];
    optional int32 bat_input_volt = 26 [(mapping_options) = { divisor: 10 }];
    optional int32 bat_op_volt = 27 [(mapping_options) = { divisor: 10 }];
    optional int32 bat_input_cur = 28 [(mapping_options) = { divisor: 10 }];
    optional int32 bat_input_watts = 29 [(mapping_options) = { divisor: 10 }];
    optional int32 bat_temp = 30 [(mapping_options) = { divisor: 10 }];
    optional uint32 bat_soc = 31;
    optional int32 llc_input_volt = 32 [(mapping_options) = { divisor: 10 }];
    optional int32 llc_op_volt = 33 [(mapping_options) = { divisor: 100 }];
    optional int32 llc_temp = 34 [(mapping_options) = { divisor: 10 }];
    optional int32 inv_input_volt = 35 [(mapping_options) = { divisor: 100 }];
    optional int32 inv_op_volt = 36 [(mapping_options) = { divisor: 10 }];
    optional int32 inv_output_cur = 37 [(mapping_options) = { divisor: 100 }];
    optional int32 inv_output_watts = 38 [(mapping_options) = { divisor: 10 }];
    optional int32 inv_temp = 39 [(mapping_options) = { divisor: 10 }];
    optional int32 inv_freq = 40 [(mapping_options) = { divisor: 10 }];
    optional int32 inv_dc_cur = 41 [(mapping_options) = { divisor: 10 }];
    optional int32 bp_type = 42;
    optional int32 inv_relay_status = 43;
    optional int32 pv1_relay_status = 44;
    optional int32 pv2_relay_status = 45;
    optional uint32 install_country = 46;
    optional uint32 install_town = 47;
    optional uint32 permanent_watts = 48 [(mapping_options) = { divisor: 10 }];
    optional uint32 dynamic_watts = 49 [(mapping_options) = { divisor: 10 }];
    optional uint32 supply_priority = 50;
    optional uint32 lower_limit = 51;
    optional uint32 upper_limit = 52;
    optional uint32 inv_on_off = 53;
    optional uint32 wireless_error_code = 54;
    optional uint32 wireless_warning_code = 55;
    optional uint32 inv_brightness = 56 [(mapping_options) = { divisor: 10 }];
    optional uint32 heartbeat_frequency = 57;
    optional uint32 rated_power = 58 [(mapping_options) = { divisor: 10 }];
    optional int32 battery_charge_remain = 59;
    optional int32 battery_discharge_remain = 60;
    optional uint32 feed_priority = 61;
    optional int32 pv_to_inv_watts = 62 [(mapping_options) = { divisor: 10 }];
    optional int32 grid_cons_watts = 63 [(mapping_options) = { divisor: 10 }];
}

message InverterHeartbeat2 {
    optional int32 H2_pv1Active = 1;
    optional int32 H2_pv1Status = 2;
    optional int32 H2_pv2Active = 3;
    optional int32 H2_pv2Status = 4;
    optional int32 H2_X_Unknown_05 = 5;
    optional int32 H2_status_06 = 6;
    optional int32 H2_upperLimit = 7;
    optional int32 H2_lowerLimit = 8;
    optional int32 H2_status_09 = 9;
    optional int32 H2_status_10 = 10;
    optional int32 H2_baseLoad = 11;
    optional int32 H2_powerPlugsPos = 12;
    optional int32 H2_X_Unknown_13 = 13;
    optional int32 H2_X_Unknown_14 = 14;
    optional int32 H2_X_Unknown_15 = 15;
    optional int32 H2_X_Unknown_16 = 16;
    optional int32 H2_X_Unknown_17 = 17;
    optional int32 H2_X_Unknown_18 = 18;
    optional int32 H2_X_Unknown_19 = 19;
    optional int32 H2_X_Unknown_20 = 20;
    optional int32 H2_X_Unknown_21 = 21;
    optional int32 H2_X_Unknown_22 = 22;
    optional int32 H2_X_Unknown_23 = 23;
    optional int32 H2_X_Unknown_24 = 24;
    optional int32 H2_X_Unknown_25 = 25;
    optional int32 H2_X_Unknown_26 = 26;
    optional int32 H2_X_Unknown_27 = 27;
    optional int32 H2_X_Unknown_28 = 28;
    optional int32 H2_X_Unknown_29 = 29;
    optional int32 H2_X_Unknown_30 = 30;
    optional int32 H2_X_Unknown_31 = 31;
    optional int32 H2_uptime = 32;
    optional int32 H2_X_Unknown_33 = 33;
    optional int32 H2_X_Unknown_34 = 34;
    optional int32 H2_X_Unknown_35 = 35;
    optional int32 H2_X_Unknown_36 = 36;
    optional int32 H2_X_Unknown_37 = 37;
    optional int32 H2_X_Unknown_38 = 38;
    optional int32 H2_X_Unknown_39 = 39;
    optional int32 H2_X_Unknown_40 = 40;
    optional int32 H2_X_Unknown_41 = 41;
    optional int32 H2_X_Unknown_42 = 42;
    optional int32 H2_X_Unknown_43 = 43;
    optional int32 H2_X_Unknown_44 = 44;
    optional int32 H2_gridWatt_45 = 45;
    optional int32 H2_powerPlugsNeg = 46;
    optional int32 H2_X_Unknown_47 = 47;
    optional int32 H2_unixtime_48 = 48;
    optional int32 H2_X_Unknown_49 = 49;
    optional int32 H2_unixtime_50 = 50;
    optional int32 H2_X_Unknown_51 = 51;
    optional int32 H2_wifiRssi = 52;
}

message Header {
	optional bytes pdata = 1;
    optional int32 src = 2;
    optional int32 dest = 3;
    optional int32 d_src= 4;
    optional int32 d_dest = 5;
    optional int32 enc_type = 6;
    optional int32 check_type = 7;
    optional int32 cmd_func = 8;
    optional int32 cmd_id = 9;
    optional int32 data_len = 10;
    optional int32 need_ack = 11;
    optional int32 is_ack = 12;
    optional int32 seq = 14;
    optional int32 product_id = 15;
    optional int32 version = 16;
    optional int32 payload_ver = 17;
    optional int32 time_snap = 18;
    optional int32 is_rw_cmd = 19;
    optional int32 is_queue = 20;
    optional int32 ack_type= 21;
    optional string code = 22;
    optional string from = 23;
    optional string module_sn = 24;
    optional string device_sn = 25;
}

message SendHeaderMsg {
    repeated Header msg = 1;
}

message SetMessage {
    Header msg = 1;
}

message SetValue {
    optional int32 value = 1;
}

message PermanentWattsPack {
  optional uint32 permanent_watts = 1;
}

message InvBrightnessPack {
  optional uint32 inv_brightness = 1;
}

message BatLowerPack {
  optional uint32 lower_limit = 1;
}

message BatUpperPack {
  optional uint32 upper_limit = 1;
}

message SupplyPriorityPack {
  optional uint32 supply_priority = 1;
}

message FeedPriorityPack {
  optional uint32 feed_priority = 1;
}

message SendMsgHart {
    optional int32 link_id = 1;
    optional int32 src = 2;
    optional int32 dest = 3;
    optional int32 d_src = 4;
    optional int32 d_dest = 5;
    optional int32 enc_type = 6;
    optional int32 check_type = 7;
    optional int32 cmd_func = 8;
    optional int32 cmd_id = 9;
    optional int32 data_len = 10;
    optional int32 need_ack = 11;
    optional int32 is_ack = 12;
    optional int32 ack_type = 13;
    optional int32 seq = 14;
    optional int32 time_snap = 15;
    optional int32 is_rw_cmd = 16;
    optional int32 is_queue = 17;
    optional int32 product_id = 18;
    optional int32 version = 19;
}
